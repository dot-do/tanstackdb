{"version":3,"sources":["../src/types/index.ts","../src/index.ts"],"sourcesContent":["import type { ZodSchema } from 'zod'\nimport type { Collection } from '@tanstack/db'\n\n// Re-export event types\nexport type {\n  MongoChangeEvent,\n  MongoInsertEvent,\n  MongoUpdateEvent,\n  MongoDeleteEvent,\n  MongoReplaceEvent,\n  ChangeMessage,\n  // Helper types\n  DocumentConstraint,\n  DocumentKey,\n  UpdateDescription,\n  ChangeType,\n  MongoOperationType,\n  EventDocument,\n  EventDocumentKey,\n  EventOperationType,\n  EventWithDocument,\n} from './events.js'\n\n// Re-export type guards\nexport {\n  isInsertEvent,\n  isUpdateEvent,\n  isDeleteEvent,\n  isReplaceEvent,\n  hasFullDocument,\n  isInsertMessage,\n  isUpdateMessage,\n  isDeleteMessage,\n} from './events.js'\n\nimport type { ChangeMessage } from './events.js'\n\n// =============================================================================\n// Branded Type Infrastructure\n// =============================================================================\n\n/**\n * Symbol used for branding types to prevent accidental type coercion.\n * Branded types are structurally unique and cannot be assigned from plain strings.\n * @internal\n */\ndeclare const BrandSymbol: unique symbol\n\n/**\n * Creates a branded type by intersecting a base type with a phantom brand property.\n *\n * Branded types provide compile-time safety by making structurally identical types\n * incompatible. This prevents mixing up values that have the same runtime type\n * but different semantic meanings.\n *\n * @typeParam T - The base type to brand\n * @typeParam Brand - A unique string literal identifier for the brand\n *\n * @example\n * ```typescript\n * type UserId = Branded<string, 'UserId'>\n * type SessionId = Branded<string, 'SessionId'>\n *\n * const userId: UserId = 'user-123' as UserId\n * const sessionId: SessionId = 'session-456' as SessionId\n *\n * // Type error: Cannot assign SessionId to UserId\n * const invalid: UserId = sessionId // Error!\n * ```\n *\n * @internal\n */\ntype Branded<T, Brand extends string> = T & { readonly [BrandSymbol]: Brand }\n\n// =============================================================================\n// Sync Mode Types\n// =============================================================================\n\n/**\n * The underlying string literal values for sync modes.\n * @internal\n */\ntype SyncModeValue = 'eager' | 'on-demand' | 'progressive'\n\n/**\n * Synchronization mode options for MongoDB collections.\n *\n * Determines when and how data is synchronized between the client and server.\n *\n * @remarks\n * Available modes:\n * - `'eager'` - Sync immediately when changes occur. Best for:\n *   - Real-time collaborative applications\n *   - Small to medium datasets\n *   - When data freshness is critical\n *\n * - `'on-demand'` - Sync only when explicitly requested. Best for:\n *   - Large datasets with infrequent updates\n *   - Bandwidth-limited environments\n *   - When user controls when to sync\n *\n * - `'progressive'` - Sync in batches over time. Best for:\n *   - Large datasets that need background sync\n *   - Initial load optimization\n *   - When you need eventual consistency\n *\n * @example Basic usage\n * ```typescript\n * const config: MongoDoCollectionConfig<User> = {\n *   // ... other config\n *   syncMode: 'eager', // Changes sync immediately\n * }\n * ```\n *\n * @example Using type guard\n * ```typescript\n * const userChoice = getUserSyncPreference()\n * if (isSyncMode(userChoice)) {\n *   config.syncMode = userChoice\n * }\n * ```\n *\n * @see {@link isSyncMode} - Type guard for runtime validation\n * @see {@link SYNC_MODES} - Array of all valid modes\n * @see {@link BrandedSyncMode} - Stricter branded version\n */\nexport type SyncMode = SyncModeValue\n\n/**\n * Branded version of SyncMode for stricter type checking scenarios.\n *\n * Use this when you need to ensure a value has been explicitly validated\n * as a sync mode through a type guard, not just any matching string.\n *\n * @example\n * ```typescript\n * function configureSyncEngine(mode: BrandedSyncMode): void {\n *   // This function only accepts validated modes\n * }\n *\n * const rawMode = 'eager'\n * // configureSyncEngine(rawMode) // Error: string not assignable to BrandedSyncMode\n *\n * if (isSyncMode(rawMode)) {\n *   configureSyncEngine(rawMode as BrandedSyncMode) // OK\n * }\n * ```\n */\nexport type BrandedSyncMode = Branded<SyncModeValue, 'SyncMode'>\n\n/**\n * Constant tuple of all valid sync mode values.\n *\n * Use for validation, iteration, or building UI components.\n *\n * @example Validation\n * ```typescript\n * const isValid = SYNC_MODES.includes(userInput as SyncMode)\n * ```\n *\n * @example Building UI\n * ```typescript\n * <select>\n *   {SYNC_MODES.map(mode => (\n *     <option key={mode} value={mode}>{mode}</option>\n *   ))}\n * </select>\n * ```\n */\nexport const SYNC_MODES: readonly SyncMode[] = ['eager', 'on-demand', 'progressive'] as const\n\n/**\n * Type guard to check if a value is a valid SyncMode.\n *\n * @param value - The value to check (can be any type)\n * @returns `true` if the value is a valid sync mode string\n *\n * @example\n * ```typescript\n * const preference = localStorage.getItem('syncMode')\n * if (isSyncMode(preference)) {\n *   // preference is now typed as SyncMode\n *   config.syncMode = preference\n * } else {\n *   config.syncMode = 'eager' // default\n * }\n * ```\n */\nexport function isSyncMode(value: unknown): value is SyncMode {\n  return typeof value === 'string' && SYNC_MODES.includes(value as SyncMode)\n}\n\n/**\n * Safely converts an unknown value to a SyncMode, returning undefined if invalid.\n *\n * @param value - The value to convert\n * @returns The value as SyncMode if valid, undefined otherwise\n *\n * @example\n * ```typescript\n * const mode = asSyncMode(process.env.SYNC_MODE) ?? 'eager'\n * config.syncMode = mode\n * ```\n */\nexport function asSyncMode(value: unknown): SyncMode | undefined {\n  return isSyncMode(value) ? value : undefined\n}\n\n// =============================================================================\n// Conflict Strategy Types\n// =============================================================================\n\n/**\n * The underlying string literal values for conflict strategies.\n * @internal\n */\ntype ConflictStrategyValue = 'last-write-wins' | 'server-wins' | 'client-wins' | 'custom'\n\n/**\n * Conflict resolution strategies for concurrent modifications.\n *\n * Determines how conflicts are resolved when the same document is modified\n * on both client and server before synchronization completes.\n *\n * @remarks\n * Available strategies:\n * - `'last-write-wins'` - The most recent write (by timestamp) takes precedence.\n *   Simple and predictable, but may lose data in concurrent edits.\n *\n * - `'server-wins'` - Server changes always override client changes.\n *   Ensures server authority, good for admin-controlled data.\n *\n * - `'client-wins'` - Client changes always override server changes.\n *   Preserves local user intent, good for offline-first apps.\n *\n * - `'custom'` - Use a custom {@link ConflictResolver} function.\n *   Most flexible, allows field-level merging or business logic.\n *\n * @example Basic usage\n * ```typescript\n * const config = {\n *   conflictStrategy: 'server-wins' as ConflictStrategy,\n * }\n * ```\n *\n * @example With custom resolver\n * ```typescript\n * const config = {\n *   conflictStrategy: 'custom' as ConflictStrategy,\n *   conflictResolver: (context) => ({\n *     resolved: { ...context.serverVersion, ...context.clientVersion }\n *   })\n * }\n * ```\n *\n * @see {@link ConflictResolver} - Custom resolution function type\n * @see {@link ConflictContext} - Context provided to resolvers\n */\nexport type ConflictStrategy = ConflictStrategyValue\n\n/**\n * Branded version of ConflictStrategy for stricter type checking.\n *\n * Use when you need to ensure values have been explicitly validated.\n */\nexport type BrandedConflictStrategy = Branded<ConflictStrategyValue, 'ConflictStrategy'>\n\n/**\n * Constant tuple of all valid conflict strategy values.\n *\n * @example\n * ```typescript\n * CONFLICT_STRATEGIES.forEach(strategy => {\n *   console.log(`Available: ${strategy}`)\n * })\n * ```\n */\nexport const CONFLICT_STRATEGIES: readonly ConflictStrategy[] = [\n  'last-write-wins',\n  'server-wins',\n  'client-wins',\n  'custom',\n] as const\n\n/**\n * Type guard to check if a value is a valid ConflictStrategy.\n *\n * @param value - The value to check\n * @returns `true` if the value is a valid conflict strategy\n *\n * @example\n * ```typescript\n * if (isConflictStrategy(userChoice)) {\n *   config.conflictStrategy = userChoice\n * }\n * ```\n */\nexport function isConflictStrategy(value: unknown): value is ConflictStrategy {\n  return typeof value === 'string' && CONFLICT_STRATEGIES.includes(value as ConflictStrategy)\n}\n\n/**\n * Safely converts an unknown value to a ConflictStrategy.\n *\n * @param value - The value to convert\n * @returns The value as ConflictStrategy if valid, undefined otherwise\n */\nexport function asConflictStrategy(value: unknown): ConflictStrategy | undefined {\n  return isConflictStrategy(value) ? value : undefined\n}\n\n// =============================================================================\n// Conflict Resolution Types\n// =============================================================================\n\n/**\n * Context provided to custom conflict resolvers.\n *\n * Contains all information needed to make an informed decision about\n * how to resolve a conflict between concurrent modifications.\n *\n * @typeParam T - The document type\n *\n * @example\n * ```typescript\n * const resolver = (context: ConflictContext<User>) => {\n *   // Compare timestamps to decide winner\n *   if (context.serverTimestamp > context.clientTimestamp) {\n *     return { resolved: context.serverVersion }\n *   }\n *\n *   // Or merge fields intelligently\n *   return {\n *     resolved: {\n *       ...context.serverVersion,\n *       name: context.clientVersion.name, // Prefer client's name change\n *       updatedAt: new Date(),\n *     }\n *   }\n * }\n * ```\n */\nexport interface ConflictContext<T = unknown> {\n  /** The document version from the server (remote state) */\n  readonly serverVersion: T\n  /** The document version from the client (local changes) */\n  readonly clientVersion: T\n  /** The common ancestor version before the conflict occurred (if available) */\n  readonly baseVersion?: T\n  /** Timestamp when the server version was last modified */\n  readonly serverTimestamp: Date\n  /** Timestamp when the client version was last modified */\n  readonly clientTimestamp: Date\n  /** The document key (typically _id) */\n  readonly key: string\n  /** The field names that have conflicting values (if determinable) */\n  readonly conflictingFields?: string[]\n  /** Additional metadata about the conflict */\n  readonly metadata?: Record<string, unknown>\n}\n\n/**\n * Result returned from a custom conflict resolver.\n *\n * @typeParam T - The document type\n */\nexport interface ConflictResolution<T = unknown> {\n  /** The resolved document value that will be persisted */\n  readonly resolved: T\n  /** Optional metadata to record about how the conflict was resolved */\n  readonly resolutionMetadata?: {\n    /** Which strategy was used (for logging/debugging) */\n    strategy?: string\n    /** Fields that were merged from server */\n    serverFields?: string[]\n    /** Fields that were merged from client */\n    clientFields?: string[]\n    /** When the resolution occurred */\n    resolvedAt?: Date\n    /** Custom metadata */\n    [key: string]: unknown\n  }\n}\n\n/**\n * Custom conflict resolver function type.\n *\n * Implement this to define custom conflict resolution logic when\n * using `conflictStrategy: 'custom'`.\n *\n * @typeParam T - The document type\n *\n * @example Simple merge resolver\n * ```typescript\n * const mergeResolver: ConflictResolver<User> = (context) => {\n *   return {\n *     resolved: {\n *       ...context.serverVersion,\n *       ...context.clientVersion,\n *       updatedAt: new Date(),\n *     },\n *     resolutionMetadata: { strategy: 'merge' }\n *   }\n * }\n * ```\n *\n * @example Field-level resolution\n * ```typescript\n * const fieldResolver: ConflictResolver<Document> = (context) => {\n *   const resolved = { ...context.serverVersion }\n *   const clientFields: string[] = []\n *\n *   // Prefer client for user-editable fields\n *   for (const field of ['title', 'content', 'tags']) {\n *     if (context.clientVersion[field] !== context.baseVersion?.[field]) {\n *       resolved[field] = context.clientVersion[field]\n *       clientFields.push(field)\n *     }\n *   }\n *\n *   return {\n *     resolved,\n *     resolutionMetadata: { strategy: 'field-level', clientFields }\n *   }\n * }\n * ```\n */\nexport type ConflictResolver<T = unknown> = (context: ConflictContext<T>) => ConflictResolution<T>\n\n// =============================================================================\n// Authentication Types\n// =============================================================================\n\n/**\n * Username and password credentials for MongoDB authentication.\n *\n * @remarks\n * Use this when connecting with basic authentication instead of an auth token.\n * For production environments, consider using auth tokens or environment variables.\n *\n * @example\n * ```typescript\n * const credentials: MongoDoCredentials = {\n *   username: 'myuser',\n *   password: process.env.MONGO_PASSWORD!,\n * }\n * ```\n */\nexport interface MongoDoCredentials {\n  /** The username for authentication */\n  username: string\n  /** The password for authentication */\n  password: string\n}\n\n// =============================================================================\n// Sync Configuration Types\n// =============================================================================\n\n/**\n * Configuration for MongoDB sync operations.\n *\n * Used for general sync configuration when not tied to a specific collection.\n *\n * @remarks\n * All properties are optional as they may be provided at different levels\n * of the configuration hierarchy.\n *\n * @example\n * ```typescript\n * const syncConfig: MongoDoSyncConfig = {\n *   endpoint: 'https://mongo.do/api',\n *   database: 'myapp',\n *   collection: 'users',\n *   syncInterval: 5000, // Sync every 5 seconds\n * }\n * ```\n */\nexport interface MongoDoSyncConfig {\n  /**\n   * The mongo.do API endpoint URL.\n   *\n   * @example 'https://mongo.do/api'\n   */\n  endpoint?: string\n\n  /**\n   * API key for authentication with the mongo.do service.\n   *\n   * @remarks\n   * This is an alternative to using username/password credentials.\n   * Store this securely and never commit to source control.\n   */\n  apiKey?: string\n\n  /**\n   * Database name to connect to.\n   *\n   * @example 'myapp-production'\n   */\n  database?: string\n\n  /**\n   * Collection name to sync with.\n   *\n   * @example 'users'\n   */\n  collection?: string\n\n  /**\n   * Sync interval in milliseconds.\n   *\n   * @remarks\n   * Only applicable when `syncMode` is `'progressive'`.\n   * Lower values mean more frequent syncs but higher bandwidth usage.\n   *\n   * @defaultValue 10000\n   * @example 5000 // Sync every 5 seconds\n   */\n  syncInterval?: number\n}\n\n// =============================================================================\n// Collection Configuration Types\n// =============================================================================\n\n/**\n * Configuration for creating a MongoDB collection adapter.\n *\n * This interface defines all the options needed to connect a TanStack DB\n * collection to a MongoDB backend via the mongo.do service.\n *\n * @typeParam TDocument - The document type stored in the collection.\n *   Must be a valid object type that can be serialized to JSON.\n *\n * @remarks\n * The configuration is divided into required and optional properties:\n *\n * **Required properties:**\n * - `id` - Unique identifier for the collection\n * - `endpoint` - The mongo.do API endpoint\n * - `database` - Target database name\n * - `collectionName` - Target collection name\n * - `schema` - Zod schema for validation\n * - `getKey` - Function to extract document keys\n *\n * **Optional properties:**\n * - `authToken` - Bearer token for authentication\n * - `credentials` - Username/password for authentication\n * - `syncMode` - How synchronization should occur\n * - `enableChangeStream` - Enable real-time updates\n *\n * @example Basic configuration\n * ```typescript\n * import { z } from 'zod'\n * import type { MongoDoCollectionConfig } from '@tanstack/mongo-db-collection'\n *\n * const userSchema = z.object({\n *   _id: z.string(),\n *   name: z.string(),\n *   email: z.string().email(),\n * })\n *\n * type User = z.infer<typeof userSchema>\n *\n * const config: MongoDoCollectionConfig<User> = {\n *   id: 'users-collection',\n *   endpoint: 'https://mongo.do/api',\n *   database: 'myapp',\n *   collectionName: 'users',\n *   schema: userSchema,\n *   getKey: (user) => user._id,\n * }\n * ```\n *\n * @example Configuration with authentication and real-time sync\n * ```typescript\n * const config: MongoDoCollectionConfig<User> = {\n *   id: 'users-collection',\n *   endpoint: 'https://mongo.do/api',\n *   database: 'myapp',\n *   collectionName: 'users',\n *   schema: userSchema,\n *   getKey: (user) => user._id,\n *   authToken: process.env.MONGO_TOKEN,\n *   syncMode: 'eager',\n *   enableChangeStream: true,\n * }\n * ```\n *\n * @see {@link SyncMode} for available synchronization modes\n * @see {@link MongoDoCredentials} for username/password authentication\n */\nexport interface MongoDoCollectionConfig<TDocument = unknown> {\n  /**\n   * Unique identifier for this collection configuration.\n   *\n   * Used internally to track and manage the collection instance.\n   * Should be unique across all collections in your application.\n   *\n   * @example 'users-collection'\n   * @example 'products-v2'\n   */\n  id: string\n\n  /**\n   * The mongo.do API endpoint URL.\n   *\n   * This is the base URL for all API requests to the mongo.do service.\n   *\n   * @example 'https://mongo.do/api'\n   * @example 'https://custom.mongo.do/api/v2'\n   */\n  endpoint: string\n\n  /**\n   * Database name to connect to.\n   *\n   * The name of the MongoDB database that contains your collection.\n   *\n   * @example 'myapp'\n   * @example 'myapp-production'\n   */\n  database: string\n\n  /**\n   * Collection name within the database.\n   *\n   * The name of the MongoDB collection to sync with.\n   *\n   * @example 'users'\n   * @example 'products'\n   */\n  collectionName: string\n\n  /**\n   * Zod schema for document validation.\n   *\n   * Used to validate documents before they are written to the collection\n   * and to provide type inference for the document type.\n   *\n   * @remarks\n   * The schema should match the `TDocument` type parameter.\n   * All documents are validated against this schema before sync.\n   *\n   * @example\n   * ```typescript\n   * import { z } from 'zod'\n   *\n   * const userSchema = z.object({\n   *   _id: z.string(),\n   *   name: z.string(),\n   *   email: z.string().email(),\n   *   createdAt: z.date(),\n   * })\n   *\n   * // Use in config:\n   * schema: userSchema\n   * ```\n   */\n  schema: ZodSchema<TDocument>\n\n  /**\n   * Function to extract the unique key from a document.\n   *\n   * This key is used to identify documents for sync operations.\n   * Typically, this returns the `_id` field of the document.\n   *\n   * @param item - The document to extract the key from\n   * @returns A string key that uniquely identifies the document\n   *\n   * @example\n   * ```typescript\n   * // Simple _id extraction\n   * getKey: (user) => user._id\n   *\n   * // Composite key\n   * getKey: (order) => `${order.userId}-${order.orderId}`\n   * ```\n   */\n  getKey: (item: TDocument) => string\n\n  /**\n   * Optional authentication token for the mongo.do API.\n   *\n   * Use this for bearer token authentication. This is the preferred\n   * authentication method for production environments.\n   *\n   * @remarks\n   * Either `authToken` or `credentials` can be used, but not both.\n   * If neither is provided, anonymous access is attempted.\n   *\n   * @example 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...'\n   */\n  authToken?: string\n\n  /**\n   * Optional username/password credentials for authentication.\n   *\n   * Use this for basic authentication when an auth token is not available.\n   *\n   * @remarks\n   * Either `authToken` or `credentials` can be used, but not both.\n   * For production, prefer using `authToken` over credentials.\n   *\n   * @example\n   * ```typescript\n   * credentials: {\n   *   username: 'myuser',\n   *   password: process.env.MONGO_PASSWORD!,\n   * }\n   * ```\n   */\n  credentials?: MongoDoCredentials\n\n  /**\n   * Sync mode determining when data synchronization occurs.\n   *\n   * Controls the synchronization behavior between client and server.\n   *\n   * @defaultValue 'eager'\n   * @see {@link SyncMode} for available options\n   *\n   * @example\n   * ```typescript\n   * // Immediate sync for real-time apps\n   * syncMode: 'eager'\n   *\n   * // Manual sync for bandwidth-limited scenarios\n   * syncMode: 'on-demand'\n   *\n   * // Batch sync for large datasets\n   * syncMode: 'progressive'\n   * ```\n   */\n  syncMode?: SyncMode\n\n  /**\n   * Enable MongoDB change stream for real-time updates.\n   *\n   * When enabled, the collection will receive real-time updates\n   * from MongoDB via change streams.\n   *\n   * @remarks\n   * Requires a MongoDB replica set or sharded cluster.\n   * May increase bandwidth usage due to continuous connection.\n   *\n   * @defaultValue false\n   *\n   * @example\n   * ```typescript\n   * // Enable real-time updates\n   * enableChangeStream: true\n   * ```\n   */\n  enableChangeStream?: boolean\n}\n\n// =============================================================================\n// MongoDB Query Types\n// =============================================================================\n\n/**\n * MongoDB comparison operators for query filters.\n *\n * These operators can be used in `where` clauses to create complex queries.\n *\n * @typeParam T - The type of value being compared\n *\n * @example\n * ```typescript\n * const filter: MongoComparisonOperators<number> = {\n *   $gte: 18,\n *   $lt: 65\n * }\n * ```\n */\nexport interface MongoComparisonOperators<T = unknown> {\n  /** Matches values equal to the specified value */\n  $eq?: T\n  /** Matches values not equal to the specified value */\n  $ne?: T\n  /** Matches values greater than the specified value */\n  $gt?: T\n  /** Matches values greater than or equal to the specified value */\n  $gte?: T\n  /** Matches values less than the specified value */\n  $lt?: T\n  /** Matches values less than or equal to the specified value */\n  $lte?: T\n  /** Matches any of the values in the specified array */\n  $in?: T[]\n  /** Matches none of the values in the specified array */\n  $nin?: T[]\n}\n\n/**\n * MongoDB element operators for checking field existence and type.\n *\n * @example\n * ```typescript\n * // Match documents where 'email' field exists\n * const filter = { email: { $exists: true } }\n * ```\n */\nexport interface MongoElementOperators {\n  /** Matches documents that have (or don't have) the specified field */\n  $exists?: boolean\n  /** Matches documents where the field is of the specified BSON type */\n  $type?: string | number\n}\n\n/**\n * MongoDB string operators for text matching.\n *\n * @example\n * ```typescript\n * // Match names starting with 'John'\n * const filter = { name: { $regex: '^John', $options: 'i' } }\n * ```\n */\nexport interface MongoStringOperators {\n  /** Regular expression pattern to match */\n  $regex?: string | RegExp\n  /** Regular expression options (i, m, s, x) */\n  $options?: string\n}\n\n/**\n * MongoDB array operators for querying array fields.\n *\n * @typeParam T - The type of array elements\n *\n * @example\n * ```typescript\n * // Match documents with exactly 3 tags\n * const filter = { tags: { $size: 3 } }\n *\n * // Match documents with all specified tags\n * const filter = { tags: { $all: ['typescript', 'react'] } }\n * ```\n */\nexport interface MongoArrayOperators<T = unknown> {\n  /** Matches arrays with the specified number of elements */\n  $size?: number\n  /** Matches arrays containing all specified values */\n  $all?: T[]\n  /** Matches if any array element matches the condition */\n  $elemMatch?: MongoFilterCondition<T>\n}\n\n/**\n * Combined filter condition for a single field.\n *\n * Can be a direct value (equality match) or an object with operators.\n *\n * @typeParam T - The type of the field being filtered\n */\nexport type MongoFilterCondition<T = unknown> =\n  | T\n  | MongoComparisonOperators<T>\n  | MongoElementOperators\n  | MongoStringOperators\n  | MongoArrayOperators<T extends (infer U)[] ? U : never>\n\n/**\n * MongoDB logical operators for combining query conditions.\n *\n * @typeParam T - The document type being queried\n *\n * @example\n * ```typescript\n * // Match active admins OR moderators\n * const filter: MongoLogicalOperators<User> = {\n *   $or: [\n *     { role: 'admin', status: 'active' },\n *     { role: 'moderator', status: 'active' }\n *   ]\n * }\n * ```\n */\nexport interface MongoLogicalOperators<T = Record<string, unknown>> {\n  /** Joins conditions with logical AND (all must match) */\n  $and?: Array<MongoFilterQuery<T>>\n  /** Joins conditions with logical OR (any must match) */\n  $or?: Array<MongoFilterQuery<T>>\n  /** Inverts the condition (must NOT match) */\n  $not?: MongoFilterQuery<T>\n  /** Joins conditions with logical NOR (none must match) */\n  $nor?: Array<MongoFilterQuery<T>>\n}\n\n/**\n * Complete MongoDB filter query type.\n *\n * Supports field-level conditions and logical operators.\n *\n * @typeParam T - The document type being queried\n *\n * @example Simple equality\n * ```typescript\n * const filter: MongoFilterQuery<User> = {\n *   status: 'active',\n *   role: 'admin'\n * }\n * ```\n *\n * @example With operators\n * ```typescript\n * const filter: MongoFilterQuery<User> = {\n *   age: { $gte: 18, $lt: 65 },\n *   status: { $in: ['active', 'pending'] },\n *   $or: [\n *     { role: 'admin' },\n *     { permissions: { $all: ['write', 'delete'] } }\n *   ]\n * }\n * ```\n */\nexport type MongoFilterQuery<T = Record<string, unknown>> = {\n  [K in keyof T]?: MongoFilterCondition<T[K]>\n} & MongoLogicalOperators<T>\n\n/**\n * Sort direction values.\n *\n * Supports both string ('asc'/'desc') and numeric (1/-1) notation.\n */\nexport type SortDirection = 'asc' | 'desc' | 1 | -1\n\n/**\n * Sort specification for ordering query results.\n *\n * @example\n * ```typescript\n * // Single field\n * const sort: SortSpec = { createdAt: 'desc' }\n *\n * // Multiple fields (applied in order)\n * const sort: SortSpec = { status: 'asc', createdAt: -1 }\n * ```\n */\nexport type SortSpec = Record<string, SortDirection>\n\n/**\n * Cursor value type for pagination.\n *\n * Supports common MongoDB cursor value types.\n */\nexport type CursorValue = string | number | Date\n\n// =============================================================================\n// Load Subset Options\n// =============================================================================\n\n/**\n * Options for loading a subset of data from the collection.\n *\n * Provides pagination, filtering, and sorting capabilities for\n * partial data loading scenarios. This type provides proper typing\n * for MongoDB-style queries while remaining compatible with\n * TanStack DB's subset loading interface.\n *\n * @typeParam T - Optional document type for type-safe filtering.\n *               Defaults to `Record<string, unknown>` for flexible queries.\n *\n * @remarks\n * All properties are optional. When not specified, defaults are used:\n * - No filtering (all documents)\n * - No sorting (server default order)\n * - No limit (all matching documents)\n * - No offset (start from beginning)\n *\n * @example Basic pagination\n * ```typescript\n * const options: LoadSubsetOptions = {\n *   limit: 20,\n *   offset: 40, // Skip first 40, get next 20\n * }\n * ```\n *\n * @example Type-safe filtered query\n * ```typescript\n * interface User {\n *   _id: string\n *   status: 'active' | 'inactive'\n *   age: number\n * }\n *\n * const options: LoadSubsetOptions<User> = {\n *   where: {\n *     status: 'active',\n *     age: { $gte: 18 }\n *   },\n *   orderBy: { age: 'desc' },\n *   limit: 10,\n * }\n * ```\n *\n * @example Cursor-based pagination\n * ```typescript\n * const options: LoadSubsetOptions = {\n *   cursor: lastDocumentId,\n *   cursorField: '_id',\n *   limit: 20,\n * }\n * ```\n *\n * @see {@link MongoFilterQuery} for filter query syntax\n * @see {@link SortSpec} for sort specification\n */\nexport interface LoadSubsetOptions<T = Record<string, unknown>> {\n  /**\n   * Filter conditions for the query.\n   *\n   * MongoDB-style query object to filter documents. Supports equality matching,\n   * comparison operators, logical operators, and more.\n   *\n   * @example Simple equality\n   * ```typescript\n   * where: { status: 'active' }\n   * ```\n   *\n   * @example Multiple conditions (implicit AND)\n   * ```typescript\n   * where: { status: 'active', role: 'admin' }\n   * ```\n   *\n   * @example Comparison operators\n   * ```typescript\n   * where: { age: { $gte: 18, $lt: 65 } }\n   * ```\n   *\n   * @example Logical operators\n   * ```typescript\n   * where: {\n   *   status: 'active',\n   *   $or: [\n   *     { role: 'admin' },\n   *     { role: 'moderator' }\n   *   ]\n   * }\n   * ```\n   */\n  where?: MongoFilterQuery<T>\n\n  /**\n   * Sort order for the results.\n   *\n   * Specify fields and their sort direction. Fields are sorted in the\n   * order specified (first field is primary sort, etc.).\n   *\n   * @example Single field descending\n   * ```typescript\n   * orderBy: { createdAt: 'desc' }\n   * ```\n   *\n   * @example Multiple fields\n   * ```typescript\n   * orderBy: { status: 'asc', createdAt: 'desc' }\n   * ```\n   *\n   * @example Numeric notation\n   * ```typescript\n   * orderBy: { score: -1, name: 1 } // -1 = desc, 1 = asc\n   * ```\n   */\n  orderBy?: SortSpec\n\n  /**\n   * Maximum number of documents to load.\n   *\n   * Use with `offset` for traditional pagination, or with `cursor`\n   * for more efficient cursor-based pagination.\n   *\n   * @example\n   * ```typescript\n   * limit: 20 // Load at most 20 documents\n   * ```\n   */\n  limit?: number\n\n  /**\n   * Number of documents to skip before loading.\n   *\n   * Used for offset-based pagination. For large datasets,\n   * prefer cursor-based pagination for better performance.\n   *\n   * @example Page 3 of 20 items per page\n   * ```typescript\n   * offset: 40, // Skip first 40 (pages 1 and 2)\n   * limit: 20\n   * ```\n   */\n  offset?: number\n\n  /**\n   * Cursor value for cursor-based pagination.\n   *\n   * Typically the `_id` or another sortable field value from the last\n   * document in the previous page. More efficient than offset-based\n   * pagination for large datasets.\n   *\n   * @example String cursor (ObjectId)\n   * ```typescript\n   * cursor: '507f1f77bcf86cd799439011'\n   * ```\n   *\n   * @example Numeric cursor (timestamp)\n   * ```typescript\n   * cursor: 1704067200000\n   * ```\n   *\n   * @example Date cursor\n   * ```typescript\n   * cursor: new Date('2024-01-01')\n   * ```\n   */\n  cursor?: CursorValue\n\n  /**\n   * Field to use for cursor-based pagination.\n   *\n   * Specifies which field the cursor value corresponds to.\n   * Should match the primary sort field for correct results.\n   *\n   * @defaultValue '_id'\n   *\n   * @example\n   * ```typescript\n   * cursorField: 'createdAt',\n   * cursor: new Date('2024-01-01'),\n   * orderBy: { createdAt: 'desc' }\n   * ```\n   */\n  cursorField?: string\n}\n\n// =============================================================================\n// Sync Function Types\n// =============================================================================\n\n/**\n * Parameters passed to the sync function.\n *\n * Provides methods for managing sync transactions and writing changes\n * to the collection.\n *\n * @typeParam T - The document type (must be an object)\n *\n * @remarks\n * The sync process follows this lifecycle:\n * 1. Call `begin()` to start a transaction\n * 2. Call `write()` for each change to apply\n * 3. Call `commit()` to finalize the transaction\n * 4. Call `markReady()` when sync is complete\n *\n * @example\n * ```typescript\n * function mySync<T extends object>(params: SyncParams<T>) {\n *   const { begin, write, commit, markReady } = params\n *\n *   begin()\n *\n *   for (const change of changes) {\n *     write(change)\n *   }\n *\n *   commit()\n *   markReady()\n *\n *   return {\n *     cleanup: () => { /* cleanup logic *\\/ },\n *   }\n * }\n * ```\n */\nexport interface SyncParams<T extends object> {\n  /**\n   * The collection being synced.\n   *\n   * Reference to the TanStack DB collection instance.\n   */\n  collection: Collection<T>\n\n  /**\n   * Begin a sync transaction.\n   *\n   * Must be called before writing any changes.\n   * All subsequent writes are batched until `commit()` is called.\n   */\n  begin: () => void\n\n  /**\n   * Write a change message to the collection.\n   *\n   * @param change - The change message describing the operation\n   *\n   * @example\n   * ```typescript\n   * write({\n   *   type: 'insert',\n   *   key: doc._id,\n   *   value: doc,\n   * })\n   * ```\n   */\n  write: (change: ChangeMessage<T>) => void\n\n  /**\n   * Commit the sync transaction.\n   *\n   * Finalizes all writes since `begin()` was called.\n   * After commit, changes are applied to the collection.\n   */\n  commit: () => void\n\n  /**\n   * Mark the sync as ready.\n   *\n   * Indicates that the initial sync is complete and the\n   * collection is ready for use.\n   */\n  markReady: () => void\n}\n\n/**\n * Return type from sync function.\n *\n * Contains cleanup handlers and optional subset loading capability.\n *\n * @example\n * ```typescript\n * const syncReturn: SyncReturn = {\n *   cleanup: () => {\n *     // Close connections, remove listeners, etc.\n *   },\n *   loadSubset: async (options) => {\n *     // Load additional data based on options\n *   },\n * }\n * ```\n */\nexport interface SyncReturn {\n  /**\n   * Cleanup function to stop sync and release resources.\n   *\n   * Called when the collection is unmounted or sync is stopped.\n   * Should close connections, remove event listeners, etc.\n   */\n  cleanup: () => void\n\n  /**\n   * Optional function to load a subset of data.\n   *\n   * Allows loading additional data with filtering and pagination.\n   *\n   * @param options - Options for filtering and pagination\n   * @returns Promise that resolves when data is loaded\n   */\n  loadSubset?: (options: LoadSubsetOptions) => Promise<void>\n}\n\n// =============================================================================\n// Type Utilities\n// =============================================================================\n\n/**\n * Extracts the required properties from MongoDoCollectionConfig.\n *\n * Useful for creating partial configurations that only include\n * the mandatory fields.\n *\n * @typeParam TDocument - The document type stored in the collection\n *\n * @example\n * ```typescript\n * type RequiredUserConfig = RequiredMongoDoCollectionConfig<User>\n * // { id: string; endpoint: string; database: string; ... }\n * ```\n */\nexport type RequiredMongoDoCollectionConfig<TDocument = unknown> = Required<\n  Pick<\n    MongoDoCollectionConfig<TDocument>,\n    'id' | 'endpoint' | 'database' | 'collectionName' | 'schema' | 'getKey'\n  >\n>\n\n/**\n * Extracts the optional properties from MongoDoCollectionConfig.\n *\n * Useful for creating override objects that only contain optional settings.\n *\n * @typeParam TDocument - The document type stored in the collection\n *\n * @example\n * ```typescript\n * type OptionalUserConfig = OptionalMongoDoCollectionConfig<User>\n * // { authToken?: string; credentials?: MongoDoCredentials; ... }\n *\n * const overrides: OptionalUserConfig = {\n *   syncMode: 'eager',\n *   enableChangeStream: true,\n * }\n * ```\n */\nexport type OptionalMongoDoCollectionConfig<TDocument = unknown> = Partial<\n  Pick<\n    MongoDoCollectionConfig<TDocument>,\n    'authToken' | 'credentials' | 'syncMode' | 'enableChangeStream'\n  >\n>\n\n/**\n * Creates a config type with specific optional properties made required.\n *\n * @typeParam TDocument - The document type stored in the collection\n * @typeParam K - Keys of optional properties to make required\n *\n * @example\n * ```typescript\n * // Config that requires auth token\n * type AuthenticatedConfig = WithRequiredConfig<User, 'authToken'>\n *\n * // Config that requires both auth token and sync mode\n * type StrictConfig = WithRequiredConfig<User, 'authToken' | 'syncMode'>\n * ```\n */\nexport type WithRequiredConfig<\n  TDocument = unknown,\n  K extends keyof OptionalMongoDoCollectionConfig<TDocument> = never,\n> = MongoDoCollectionConfig<TDocument> & Required<Pick<MongoDoCollectionConfig<TDocument>, K>>\n\n/**\n * Extracts the document type from a MongoDoCollectionConfig.\n *\n * @typeParam TConfig - A MongoDoCollectionConfig type\n *\n * @example\n * ```typescript\n * const userConfig: MongoDoCollectionConfig<User> = { ... }\n * type ExtractedUser = InferDocumentType<typeof userConfig>\n * // User\n * ```\n */\nexport type InferDocumentType<TConfig> = TConfig extends MongoDoCollectionConfig<infer T>\n  ? T\n  : never\n\n/**\n * Type guard to check if a value is a valid MongoDoCollectionConfig.\n *\n * @param value - The value to check\n * @returns True if the value has all required properties\n *\n * @example\n * ```typescript\n * if (isMongoDoCollectionConfig(config)) {\n *   // config is typed as MongoDoCollectionConfig<unknown>\n *   console.log(config.id, config.endpoint)\n * }\n * ```\n */\nexport function isMongoDoCollectionConfig(\n  value: unknown\n): value is MongoDoCollectionConfig<unknown> {\n  if (!value || typeof value !== 'object') return false\n  const config = value as Record<string, unknown>\n  return (\n    typeof config.id === 'string' &&\n    typeof config.endpoint === 'string' &&\n    typeof config.database === 'string' &&\n    typeof config.collectionName === 'string' &&\n    typeof config.schema === 'object' &&\n    typeof config.getKey === 'function'\n  )\n}\n","/**\n * @tanstack/mongo-db-collection\n *\n * TanStack DB adapter for MongoDB via mongo.do API.\n * Provides real-time synchronization between TanStack DB collections\n * and MongoDB databases with support for change streams.\n *\n * @packageDocumentation\n * @module @tanstack/mongo-db-collection\n */\n\n// ============================================================================\n// Type Exports\n// ============================================================================\n\n/**\n * Re-export all types for convenient access.\n * Types are organized into three categories:\n * - Configuration types: Adapter configuration interfaces\n * - Event types: MongoDB change stream event representations\n * - Type utilities: Helper types for working with configurations\n */\nexport type {\n  // Configuration types\n  MongoDoCollectionConfig,\n  MongoDoSyncConfig,\n  MongoDoCredentials,\n  SyncParams,\n  SyncReturn,\n  SyncMode,\n  ConflictStrategy,\n  LoadSubsetOptions,\n  // Event types\n  ChangeMessage,\n  MongoChangeEvent,\n  MongoInsertEvent,\n  MongoUpdateEvent,\n  MongoDeleteEvent,\n  MongoReplaceEvent,\n  // Type utilities\n  RequiredMongoDoCollectionConfig,\n  OptionalMongoDoCollectionConfig,\n  WithRequiredConfig,\n  InferDocumentType,\n} from './types.js'\n\n// Re-export type guard function\nexport { isMongoDoCollectionConfig } from './types.js'\n\n// ============================================================================\n// Internal Imports\n// ============================================================================\n\nimport type { MongoDoCollectionConfig } from './types.js'\n\n// ============================================================================\n// Public API\n// ============================================================================\n\n/**\n * Creates collection options for use with TanStack DB.\n *\n * This is the primary factory function for configuring a MongoDB collection\n * adapter. It accepts a configuration object and returns it typed correctly\n * for use with TanStack DB's collection system.\n *\n * @template TDocument - The document type stored in the MongoDB collection.\n *   Must be compatible with the provided Zod schema.\n *\n * @param config - Configuration for the MongoDB collection adapter\n * @param config.id - Unique identifier for this collection configuration\n * @param config.endpoint - The mongo.do API endpoint URL\n * @param config.database - MongoDB database name\n * @param config.collectionName - MongoDB collection name\n * @param config.schema - Zod schema for document validation\n * @param config.getKey - Function to extract a unique key from a document\n * @param config.authToken - Optional authentication token\n * @param config.credentials - Optional username/password credentials\n * @param config.syncMode - Sync strategy: 'eager', 'on-demand', or 'progressive'\n * @param config.enableChangeStream - Enable real-time updates via change streams\n *\n * @returns The validated collection configuration\n *\n * @example\n * Basic usage with a User collection:\n * ```typescript\n * import { z } from 'zod'\n * import { mongoDoCollectionOptions } from '@tanstack/mongo-db-collection'\n *\n * const userSchema = z.object({\n *   _id: z.string(),\n *   name: z.string(),\n *   email: z.string().email(),\n *   createdAt: z.date(),\n * })\n *\n * type User = z.infer<typeof userSchema>\n *\n * const userCollectionConfig = mongoDoCollectionOptions<User>({\n *   id: 'users',\n *   endpoint: 'https://api.mongo.do',\n *   database: 'myapp',\n *   collectionName: 'users',\n *   schema: userSchema,\n *   getKey: (user) => user._id,\n *   syncMode: 'eager',\n *   enableChangeStream: true,\n * })\n * ```\n *\n * @example\n * With authentication:\n * ```typescript\n * const secureConfig = mongoDoCollectionOptions<User>({\n *   id: 'users',\n *   endpoint: 'https://api.mongo.do',\n *   database: 'myapp',\n *   collectionName: 'users',\n *   schema: userSchema,\n *   getKey: (user) => user._id,\n *   authToken: process.env.MONGO_DO_TOKEN,\n * })\n * ```\n *\n * @see {@link MongoDoCollectionConfig} for full configuration options\n * @see {@link createMongoDoCollection} for an alternative API\n */\nexport function mongoDoCollectionOptions<TDocument = unknown>(\n  config: MongoDoCollectionConfig<TDocument>\n): MongoDoCollectionConfig<TDocument> {\n  return config\n}\n\n/**\n * Creates a MongoDB collection adapter configuration.\n *\n * This is an alias for {@link mongoDoCollectionOptions} that provides\n * a more descriptive name for developers who prefer explicit naming.\n * Both functions are functionally identical.\n *\n * @template TDocument - The document type stored in the MongoDB collection\n *\n * @param config - Configuration for the MongoDB collection adapter\n * @returns A configured collection adapter options object\n *\n * @example\n * ```typescript\n * import { z } from 'zod'\n * import { createMongoDoCollection } from '@tanstack/mongo-db-collection'\n *\n * const productSchema = z.object({\n *   _id: z.string(),\n *   sku: z.string(),\n *   name: z.string(),\n *   price: z.number().positive(),\n * })\n *\n * type Product = z.infer<typeof productSchema>\n *\n * const productConfig = createMongoDoCollection<Product>({\n *   id: 'products',\n *   endpoint: 'https://api.mongo.do',\n *   database: 'ecommerce',\n *   collectionName: 'products',\n *   schema: productSchema,\n *   getKey: (product) => product._id,\n *   syncMode: 'progressive',\n * })\n * ```\n *\n * @see {@link mongoDoCollectionOptions} for the primary API\n * @see {@link MongoDoCollectionConfig} for full configuration options\n */\nexport function createMongoDoCollection<TDocument = unknown>(\n  config: MongoDoCollectionConfig<TDocument>\n): MongoDoCollectionConfig<TDocument> {\n  return mongoDoCollectionOptions(config)\n}\n"],"mappings":";AAm1CO,SAAS,0BACd,OAC2C;AAC3C,MAAI,CAAC,SAAS,OAAO,UAAU,SAAU,QAAO;AAChD,QAAM,SAAS;AACf,SACE,OAAO,OAAO,OAAO,YACrB,OAAO,OAAO,aAAa,YAC3B,OAAO,OAAO,aAAa,YAC3B,OAAO,OAAO,mBAAmB,YACjC,OAAO,OAAO,WAAW,YACzB,OAAO,OAAO,WAAW;AAE7B;;;ACjuCO,SAAS,yBACd,QACoC;AACpC,SAAO;AACT;AA0CO,SAAS,wBACd,QACoC;AACpC,SAAO,yBAAyB,MAAM;AACxC;","names":[]}